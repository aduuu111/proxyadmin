技术栈确认
后端 (BFF): Python (FastAPI) + SQLite (SQLAlchemy)

前端: Vue 3 + Vite + Element Plus + Pinia

核心交互: httpx (用于请求底层 OpenAPI)

阶段一：数据库建模与基础架构
目标：建立“独立的数据中心”，确保持久化存储所有配置。

给 AI 的提示词 (Prompt 1):

我们现在开始开发代理管理系统的后端。技术栈是 FastAPI + SQLite (SQLAlchemy) + Pydantic。

请首先帮我编写 models.py 和 database.py，设计以下数据库表结构（请包含 created_at 和 updated_at）：

Admin (管理员表): id, username, password_hash, avatar.

Outbound (出站器表):

核心字段: name (唯一), protocol (direct/socks/http/ss), config (JSON类型, 存 ip/port/user/pass 等), local_interface_ip (对应 api 的 eh).

UI字段: remark (备注), is_auto_generated (布尔值, 标记是否为一键生成的本机IP).

Rule (规则表):

核心字段: name (唯一), content (对应 api 的 data).

UI字段: priority (排序), remark.

User (用户表 - 核心):

核心字段: username, password, port (listenAddr的端口), protocol (socks5/ss), total_traffic (流量限额), expire_time (datetime), outbound_id (关联 Outbound 表), rule_id (关联 Rule 表).

状态字段: enable (布尔值), status (active/expired).

统计字段: up_traffic (已用上行), down_traffic (已用下行), last_seen (最后在线时间).

UI字段: remark (备注), email (联系方式).

请确保使用 SQLAlchemy 2.0 风格，并写一个 init_db.py 脚本用于初始化数据库并创建一个默认管理员 (admin/admin)。

阶段二：核心适配器 (Core Adapter)
目标：封装底层 API，让后端能“遥控”核心程序。

给 AI 的提示词 (Prompt 2):

我有一个运行在 http://127.0.0.1:xxx 的核心代理程序，它有 OpenAPI 文档。请帮我编写一个 core_client.py 模块，使用 httpx 异步库封装与核心的交互。

需要实现以下功能类 CoreAdapter：

鉴权: 所有请求 Header 需带 Auth: {api_key}。

系统信息: 封装 /api/system/getInterFaces 和 /api/system/current/all/all。

同步逻辑 (关键):

sync_outbound(data): 调用 /api/out/createOutBound。

sync_user(data): 判断是新用户还是修改。如果核心里没有该端口，调用 /api/user/createUser；如果有，调用 /api/user/editUser。

delete_user(port): 调用 /api/user/deleteUser。

reload_rule(name, data): 调用规则相关 API。

异常处理: 如果连接核心失败，不要让程序崩溃，而是抛出自定义异常 CoreConnectionError。

阶段三：业务逻辑层 (Service Layer)
目标：实现 X-UI 的核心逻辑（状态管理、一键恢复、一键生成）。

给 AI 的提示词 (Prompt 3):

现在编写业务逻辑层 services/。请实现以下核心逻辑：

用户管理逻辑 (user_service.py):

添加/更新用户: 接收前端表单 -> 保存到 SQLite -> 检查 enable 状态和 expire_time。

逻辑分支:

如果 enable=True 且 未过期: 调用 CoreAdapter.sync_user 推送到核心运行。

如果 enable=False 或 已过期: 仅更新 SQLite 状态，并调用 CoreAdapter.delete_user 确保核心停止该端口服务。

重置用户: 提供一个方法，当用户过期后，管理员修改过期时间并点击“启用”，系统应自动重置其状态并重新推送到 Core。

出站器逻辑 (outbound_service.py):

一键扫描: 调用 CoreAdapter.get_inter_faces 获取本机所有网卡 IP，自动在 SQLite 中创建对应的 "Direct" 类型出站器（去重），并推送到 Core。

系统面板逻辑 (system_service.py):

仪表盘数据: 聚合 CoreAdapter 的系统负载数据。

数据库备份: 实现一个函数，直接返回 sqlite.db 文件的二进制流，用于前端下载。

阶段四：Web API 路由开发
目标：将业务逻辑暴露给前端。

给 AI 的提示词 (Prompt 4):

基于 FastAPI 编写 routers/。需要 JWT 鉴权 (Depends(get_current_admin))。

POST /api/login: 登录返回 Token。

GET /api/dashboard: 返回 CPU/内存/带宽/在线用户数/系统版本。

GET /api/backup: 响应 FileResponse 下载数据库文件。

User CRUD: 包含 POST /user/reset_traffic (重置流量) 和 POST /user/toggle (启用/禁用)。

Outbound CRUD: 包含 POST /outbound/scan (执行一键扫描本机IP)。

Settings: POST /settings/update_admin (修改账号密码)。

阶段五：前端开发 (Vue 3 + Element Plus)
目标：构建可视化界面。这一步内容较多，建议拆分为两个子步骤。

子步骤 5.1: 框架与布局

给 AI 的提示词: 现在开发前端，使用 Vue 3, Vite, Element Plus, Pinia, Vue Router。

搭建侧边栏布局 (Layout)，包含菜单：仪表盘、出站管理、规则管理、用户列表、面板设置。

封装 Axios，自动在 Header 携带 Token，处理 401 跳转登录页。

编写 Login.vue 和 Dashboard.vue (展示系统负载卡片，以及一个“备份数据库”的大按钮)。

子步骤 5.2: 核心功能页面

给 AI 的提示词: 请编写以下核心页面组件：

OutboundList.vue: 表格展示。顶部有一个“一键扫描本机IP”按钮。支持添加自定义出站器 (Socks5/HTTP代理)。

UserList.vue (重中之重):

表格列: 状态(红/绿灯), 备注, 端口, 协议, 已用流量/总量, 到期时间, 剩余天数, 操作(编辑/重置流量/删除)。

状态逻辑: 如果 expire_time < now，显示红色“已过期”标签。

编辑/添加弹窗: 包含所有用户字段。

核心交互: 当点击某行“编辑”时，如果是已过期用户，管理员修改到期时间为未来，并勾选“启用”，前端保存后，后端会自动恢复该服务。

Settings.vue: 简单的表单，修改管理员用户名和密码。